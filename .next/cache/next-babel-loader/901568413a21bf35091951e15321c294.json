{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\n// #region Global Imports\nimport \"isomorphic-unfetch\";\nimport { stringify } from \"query-string\"; // #endregion Global Imports\n// #region Interface Imports\n\n// #endregion Interface Imports\nvar BaseUrl = \"\".concat(process.env.NEXT_PUBLIC_API_URL, \"/api\");\nexport var Http = {\n  Request: function () {\n    var _Request = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(methodType, url, params, payload) {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                var query = params ? \"?\".concat(stringify(_objectSpread(_objectSpread({}, params), {}, {\n                  api_key: process.env.NEXT_PUBLIC_API_KEY\n                }))) : \"\";\n                fetch(\"\".concat(BaseUrl).concat(url).concat(query), {\n                  body: JSON.stringify(payload),\n                  cache: \"no-cache\",\n                  headers: {\n                    \"content-type\": \"application/json\"\n                  },\n                  method: \"\".concat(methodType)\n                }).then( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(response) {\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            if (!(response.status === 200)) {\n                              _context.next = 2;\n                              break;\n                            }\n\n                            return _context.abrupt(\"return\", response.json().then(resolve));\n\n                          case 2:\n                            return _context.abrupt(\"return\", reject(response));\n\n                          case 3:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x5) {\n                    return _ref.apply(this, arguments);\n                  };\n                }())[\"catch\"](function (e) {\n                  reject(e);\n                });\n              }));\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function Request(_x, _x2, _x3, _x4) {\n      return _Request.apply(this, arguments);\n    }\n\n    return Request;\n  }()\n};","map":{"version":3,"sources":["/Users/rajandas/Desktop/Projects/Template/next-boilerplate/src/Services/API/Http/index.ts"],"names":["stringify","BaseUrl","process","env","NEXT_PUBLIC_API_URL","Http","Request","methodType","url","params","payload","Promise","resolve","reject","query","api_key","NEXT_PUBLIC_API_KEY","fetch","body","JSON","cache","headers","method","then","response","status","json","e"],"mappings":";;;;;;;;AAAA;AACA,OAAO,oBAAP;AACA,SAASA,SAAT,QAA0B,cAA1B,C,CACA;AAEA;;AAEA;AAEA,IAAMC,OAAO,aAAMC,OAAO,CAACC,GAAR,CAAYC,mBAAlB,SAAb;AACA,OAAO,IAAMC,IAAI,GAAG;AAChBC,EAAAA,OAAO;AAAA,4EAAE,kBACLC,UADK,EAELC,GAFK,EAGLC,MAHK,EAILC,OAJK;AAAA;AAAA;AAAA;AAAA;AAAA,gDAME,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACpC,oBAAMC,KAAK,GAAGL,MAAM,cACVT,SAAS,iCACNS,MADM;AAETM,kBAAAA,OAAO,EAAEb,OAAO,CAACC,GAAR,CAAYa;AAFZ,mBADC,IAKd,EALN;AAOAC,gBAAAA,KAAK,WAAIhB,OAAJ,SAAcO,GAAd,SAAoBM,KAApB,GAA6B;AAC9BI,kBAAAA,IAAI,EAAEC,IAAI,CAACnB,SAAL,CAAeU,OAAf,CADwB;AAE9BU,kBAAAA,KAAK,EAAE,UAFuB;AAG9BC,kBAAAA,OAAO,EAAE;AACL,oCAAgB;AADX,mBAHqB;AAM9BC,kBAAAA,MAAM,YAAKf,UAAL;AANwB,iBAA7B,CAAL,CAQKgB,IARL;AAAA,sFAQU,iBAAMC,QAAN;AAAA;AAAA;AAAA;AAAA;AAAA,kCACEA,QAAQ,CAACC,MAAT,KAAoB,GADtB;AAAA;AAAA;AAAA;;AAAA,6DAESD,QAAQ,CAACE,IAAT,GAAgBH,IAAhB,CAAqBX,OAArB,CAFT;;AAAA;AAAA,6DAIKC,MAAM,CAACW,QAAD,CAJX;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,mBARV;;AAAA;AAAA;AAAA;AAAA,8BAcW,UAAAG,CAAC,EAAI;AACRd,kBAAAA,MAAM,CAACc,CAAD,CAAN;AACH,iBAhBL;AAiBH,eAzBM,CANF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAF;;AAAA;AAAA;AAAA;;AAAA;AAAA;AADS,CAAb","sourcesContent":["// #region Global Imports\nimport \"isomorphic-unfetch\";\nimport { stringify } from \"query-string\";\n// #endregion Global Imports\n\n// #region Interface Imports\nimport { HttpModel } from \"@Interfaces\";\n// #endregion Interface Imports\n\nconst BaseUrl = `${process.env.NEXT_PUBLIC_API_URL}/api`;\nexport const Http = {\n    Request: async <A>(\n        methodType: string,\n        url: string,\n        params?: HttpModel.IRequestQueryPayload,\n        payload?: HttpModel.IRequestPayload\n    ): Promise<A> => {\n        return new Promise((resolve, reject) => {\n            const query = params\n                ? `?${stringify({\n                      ...params,\n                      api_key: process.env.NEXT_PUBLIC_API_KEY,\n                  })}`\n                : \"\";\n\n            fetch(`${BaseUrl}${url}${query}`, {\n                body: JSON.stringify(payload),\n                cache: \"no-cache\",\n                headers: {\n                    \"content-type\": \"application/json\",\n                },\n                method: `${methodType}`,\n            })\n                .then(async response => {\n                    if (response.status === 200) {\n                        return response.json().then(resolve);\n                    }\n                    return reject(response);\n                })\n                .catch(e => {\n                    reject(e);\n                });\n        });\n    },\n};\n"]},"metadata":{},"sourceType":"module"}