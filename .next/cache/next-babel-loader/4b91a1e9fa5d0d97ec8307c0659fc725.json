{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// #region Global Imports\nimport \"isomorphic-unfetch\";\nimport { stringify } from \"query-string\"; // #endregion Global Imports\n// #region Interface Imports\n\n// #endregion Interface Imports\nconst BaseUrl = `${process.env.NEXT_PUBLIC_API_URL}/api`;\nexport const Http = {\n  Request: async (methodType, url, params, payload) => {\n    return new Promise((resolve, reject) => {\n      const query = params ? `?${stringify(_objectSpread(_objectSpread({}, params), {}, {\n        api_key: process.env.NEXT_PUBLIC_API_KEY\n      }))}` : \"\";\n      fetch(`${BaseUrl}${url}${query}`, {\n        body: JSON.stringify(payload),\n        cache: \"no-cache\",\n        headers: {\n          \"content-type\": \"application/json\"\n        },\n        method: `${methodType}`\n      }).then(async response => {\n        if (response.status === 200) {\n          return response.json().then(resolve);\n        }\n\n        return reject(response);\n      }).catch(e => {\n        reject(e);\n      });\n    });\n  }\n};","map":{"version":3,"sources":["/Users/rajandas/Desktop/Projects/Template/next-boilerplate/src/Services/API/Http/index.ts"],"names":["stringify","BaseUrl","process","env","NEXT_PUBLIC_API_URL","Http","Request","methodType","url","params","payload","Promise","resolve","reject","query","api_key","NEXT_PUBLIC_API_KEY","fetch","body","JSON","cache","headers","method","then","response","status","json","catch","e"],"mappings":";;;;;;AAAA;AACA,OAAO,oBAAP;AACA,SAASA,SAAT,QAA0B,cAA1B,C,CACA;AAEA;;AAEA;AAEA,MAAMC,OAAO,GAAI,GAAEC,OAAO,CAACC,GAAR,CAAYC,mBAAoB,MAAnD;AACA,OAAO,MAAMC,IAAI,GAAG;AAChBC,EAAAA,OAAO,EAAE,OACLC,UADK,EAELC,GAFK,EAGLC,MAHK,EAILC,OAJK,KAKQ;AACb,WAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACpC,YAAMC,KAAK,GAAGL,MAAM,GACb,IAAGT,SAAS,iCACNS,MADM;AAETM,QAAAA,OAAO,EAAEb,OAAO,CAACC,GAAR,CAAYa;AAFZ,SAGV,EAJW,GAKd,EALN;AAOAC,MAAAA,KAAK,CAAE,GAAEhB,OAAQ,GAAEO,GAAI,GAAEM,KAAM,EAA1B,EAA6B;AAC9BI,QAAAA,IAAI,EAAEC,IAAI,CAACnB,SAAL,CAAeU,OAAf,CADwB;AAE9BU,QAAAA,KAAK,EAAE,UAFuB;AAG9BC,QAAAA,OAAO,EAAE;AACL,0BAAgB;AADX,SAHqB;AAM9BC,QAAAA,MAAM,EAAG,GAAEf,UAAW;AANQ,OAA7B,CAAL,CAQKgB,IARL,CAQU,MAAMC,QAAN,IAAkB;AACpB,YAAIA,QAAQ,CAACC,MAAT,KAAoB,GAAxB,EAA6B;AACzB,iBAAOD,QAAQ,CAACE,IAAT,GAAgBH,IAAhB,CAAqBX,OAArB,CAAP;AACH;;AACD,eAAOC,MAAM,CAACW,QAAD,CAAb;AACH,OAbL,EAcKG,KAdL,CAcWC,CAAC,IAAI;AACRf,QAAAA,MAAM,CAACe,CAAD,CAAN;AACH,OAhBL;AAiBH,KAzBM,CAAP;AA0BH;AAjCe,CAAb","sourcesContent":["// #region Global Imports\nimport \"isomorphic-unfetch\";\nimport { stringify } from \"query-string\";\n// #endregion Global Imports\n\n// #region Interface Imports\nimport { HttpModel } from \"@Interfaces\";\n// #endregion Interface Imports\n\nconst BaseUrl = `${process.env.NEXT_PUBLIC_API_URL}/api`;\nexport const Http = {\n    Request: async <A>(\n        methodType: string,\n        url: string,\n        params?: HttpModel.IRequestQueryPayload,\n        payload?: HttpModel.IRequestPayload\n    ): Promise<A> => {\n        return new Promise((resolve, reject) => {\n            const query = params\n                ? `?${stringify({\n                      ...params,\n                      api_key: process.env.NEXT_PUBLIC_API_KEY,\n                  })}`\n                : \"\";\n\n            fetch(`${BaseUrl}${url}${query}`, {\n                body: JSON.stringify(payload),\n                cache: \"no-cache\",\n                headers: {\n                    \"content-type\": \"application/json\",\n                },\n                method: `${methodType}`,\n            })\n                .then(async response => {\n                    if (response.status === 200) {\n                        return response.json().then(resolve);\n                    }\n                    return reject(response);\n                })\n                .catch(e => {\n                    reject(e);\n                });\n        });\n    },\n};\n"]},"metadata":{},"sourceType":"module"}